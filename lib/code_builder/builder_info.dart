import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:build/build.dart';
import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';

import '../code_builder_code/application_info_code.dart';
import '../code_builder_code/service_class_info_code.dart';
import 'info_json.dart';

/// using main because that way we can simply debug:
/// - Read reflect_info.json
/// - create dart files

main() {
  String jsonString = File(
          'C:/Users/nilsth/AndroidStudioProjects/flutter-reflect-framework/.dart_tool/build/generated/reflect_framework/lib/reflect_info.combined.json')
      .readAsStringSync();
  var json = jsonDecode(jsonString);
  _createReflectGeneratedLibFile(json);
}

const reflectGeneratedFile = 'generated.dart';
const reflectGeneratedPath = 'lib/' + reflectGeneratedFile;

void _createReflectGeneratedLibFile(json) {
  File file = File(reflectGeneratedPath);
  String dartCode = _createReflectGeneratedLibCode(json);
  file.writeAsString(dartCode);
}

String _createReflectGeneratedLibCode(json) {
  Library reflectGeneratedLib = _createReflectGeneratedLib(json);
  final emitter = DartEmitter(Allocator.simplePrefixing());
  String dartCode = _createHeaderComment() +
      DartFormatter().format('${reflectGeneratedLib.accept(emitter)}');
  return dartCode;
}

String _createHeaderComment() {
  return '''
/// This code is generated by [ReflectInfoBuilder].
/// Do not modify or remove this code! 
/// Regenerate it if needed using the following command: flutter packages pub run build_runner build lib --delete-conflicting-outputs
 
''';
}

Library _createReflectGeneratedLib(json) {
  ReflectJson reflectJson = _readReflectInfoJsonFile(json);
  final generatedLib = Library((b) => b.body
    ..add(ApplicationInfoFactory(reflectJson).createCode())
    ..addAll(ServiceClassInfoFactory().createCodes(reflectJson)));

  return generatedLib;
  // ApplicationInfoCode applicationInfoCode=ApplicationInfoCode(reflectInfo);
  // List<ExecutableInfo> preProcessors=reflectInfo.findActionMethodPreProcessorFunctions();
  // List<ExecutableInfo> processors=reflectInfo.findActionMethodProcessorFunctions();
  // List<ClassInfo> serviceClasses= reflectInfo.findPotentialServiceClasses( preProcessors,processors);
  // ServiceClassesInfoCode serviceClassesInfoCode=ServiceClassesInfoCode(reflectInfo);
  // List<ServiceClassInfoCode> serviceClassInfoCodes=serviceClasses.map((s) => ServiceClassInfoCode(s));
  // List<ClassInfo> domainClasses= reflectInfo.findPotentialDomainClasses(serviceClasses);
  // List<DomainClassInfoCode> domainClassCodes=serviceClasses.map((s) => DomainClassInfoCode(s));
}

ReflectJson _readReflectInfoJsonFile(json) {
  return ReflectJson.fromJson(json);
}

///Uses the reflect_info.json file to generate a reflect_generated library with info classes
class ReflectInfoBuilder implements Builder {
  @override
  Map<String, List<String>> get buildExtensions => {
        '.combined.json': ['/../' + reflectGeneratedFile]
      };

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    try {
      String jsonString = await buildStep.readAsString(buildStep.inputId);
      var json = jsonDecode(jsonString);

      String dartCode = _createReflectGeneratedLibCode(json);
      AssetId destination =
          AssetId(buildStep.inputId.package, reflectGeneratedPath);
      buildStep.writeAsString(destination, dartCode);
    } catch (exception, stacktrace) {
      print('$exception\n$stacktrace');
    }
  }
}
